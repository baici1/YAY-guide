# Mysql

参考以及推荐文章：

> * [B树、B+树索引算法原理（上）](https://www.codedump.info/post/20200609-btree-1/)
> * [javaGuide](https://javaguide.cn/database/mysql/mysql-index/#b-%E6%A0%91-b-%E6%A0%91)

## 基础

### 1.什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?简写分别是什么？

**数据库** : 数据库(`DataBase` 简称 `DB`)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。

**数据库管理系统** : 数据库管理系统(`Database Management System` 简称 `DBMS`)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。

**数据库系统** : 数据库系统(`Data Base System`，简称 `DBS`)通常由软件、数据库和数据管理员(DBA)组成。

**数据库管理员** : 数据库管理员(`Database Administrator`, 简称 `DBA`)负责全面管理和控制数据库系统。

### 2.主键，外键有什么区别?为什么不是很推荐使用外键？

|      | 主键                                           | 外键                                                 |
| ---- | ---------------------------------------------- | ---------------------------------------------------- |
| 定义 | 用于唯一标识一个元组，不能有重复，不允许为空。 | 表的外键是另一表的主键, 外键可以有重复的, 可以是空值 |
| 作用 | 保证数据完整性，提供元组的位置信息             | 用来和其他表建立联系用的                             |
| 个数 | 一个表只能有一个                               | 一个表可以有多个外键                                 |

外键的优点：

* 由数据库自身最大限度保证数据一致性，完整性
* 在一定程度上，说明了业务逻辑，设计更加全面。增加ER图可读性
* 联级操作方便。

缺点：

* 增加了复杂性，会平添开发难度，导致表更多等问题
* 维护工作复杂
* 降低耦合度，影响性能，对分库分表会造成影响。

既然有外键，那么肯定有他存在的开发环境，当回答这种问题，不能一味的否定，现在项目越来越复杂，外键弊大于利，但是如果你的项目轻量，不分库分表，对性能没有要求，其实可以使用外键去简化一些过程的。

### 3.数据库三范式分别是什么？

- 1NF：属性不可再分。
- 2NF：1NF 的基础之上，消除了非主属性对于码的部分函数依赖，换句话说非主属性对码完全函数依赖。
- 3NF：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。

### 4.Mysql引擎支持哪些引擎？讲讲常用 MyISAM 和 InnoDB 的区别。

![image-20220304212100214](https://cdn.jsdelivr.net/gh/baici1/image-host/image-20220304212100214.png)

支持的引擎如上。

`MyISAM` 和 `InnoDB` 的区别从以下几个方面说明：

1. 是否支持行级锁

`MyISAM`：不提供行级锁，当处理并发时候，利用表锁。

`InnoDB`：支持行级锁，权限细粒度更低，并发上比 `MyISAM` 更好。

2. 是否支持事务

`MyISAM`：不支持事务。

`InnoDB`：支持事务，具有提交(commit)和回滚(rollback)事务的能力。

3. 是否支持数据库异常崩溃后的安全恢复。

`MyISAM`：不支持

`InnoDB`：支持，利用 **redo log(重做日志)** 将数据库状态恢复到你想要任意时刻。

## 索引

### 1.什么是索引？常用结构是什么？

**索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。**

### 2.索引的优缺点

优点：

* 大大加快数据的检索速度，这是主要原因
* 使用分组和排序语句，性能会有显著的提高。
* 唯一性索引，保证数据库中每一行数据的唯一性

缺点：

* 创建索引和维护索引需要时间，随着数据量变大，时间需要的更多。当表中数据发生更新时候，索引也需要动态维护。
* 创建索引占据空间，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。

### 3.使用索引一定会提高查询速度？索引有哪些使用场景？

不一定！

场景很多，举常用的例子。

推荐使用索引场景：

* 主键长度小，建立唯一索引
* 频繁用作查询条件的字段建立索引
* 需要排序或分组的字段建立索引
* 多个字段需要被查询建立复合索引

不推荐建立索引场景：

* 表的记录少，这时候全表扫描和索引查询时间差不多的。
* 增删改操作多，查询少的表不建议建立索引，当你进行增删改时候，需要时间去维护索引。
* 数据重复且分布平均的表字段，此时建立索引没有太大的实际效果。

### 4.索引的底层数据结构聊一聊。

索引常见的数据结构：B 树， B+树和 Hash。

#### Hash

hash 索引基于哈希表实现，哈希表是 (k,v) 键对的集合，可以通过键值 (k) 快速取到对应的值 (v)。**MySQL中，只有Memory存储引擎显示支持hash索引，是Memory表的默认索引类型**。

**实现原理**：对于每一行数据，存储引擎会对索引列根据哈希函数计算一个**哈希值**，哈希索引将所有的哈希值存储在索引中，同时保存指向每个数据行的指针。哈希函数会存在哈希冲突，解决方法：链地址法（如果有多个列的哈希值相同，索引会以链表方式存放多个记录指针）

![img](https://img-blog.csdnimg.cn/20210513092224836.png)

使用限制：

* 哈希索引数据不是按照索引值顺序存储，不能用于排序。
* 哈希索引不支持部分索引查找，必须使用所有的索引列来查找。
* 哈希索引只支持等值查询（=,IN(),<,=,<），不支持范围查询。
* 哈希冲突会影响查询速度。

 **总结：**哈希索引限制多，只适用于一定的场合（等值查询）。而一旦适合哈希索引，它带来的性能提升将非常显著。

#### B树&B+树

推荐阅读：

* [B树](https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653190965&idx=1&sn=53f78fa037386f85531832cd5322d2a0&chksm=8c9909efbbee80f90512f0c36356c31cc74c388c46388dc2317d43c8f8597298f233ca9c29e9&scene=21#wechat_redirect)/[B+树](https://mp.weixin.qq.com/s/jRZMMONW3QP43dsDKIV9VQ?)
* [B树算法原理](https://www.codedump.info/post/20200609-btree-1/)

在一堆数据中查询一个数据时候，常用的数据结构二叉查找树（`binary search tree`，简称BST）、哈希桶等。以` BST` 为例，常见的实现有 `AVT`、红黑树等，由于这类型的树是平衡的，每次比较操作都会去掉当前数据量一半的数据，因此查找的时间复杂度为`O(logn)`。

![bst-example](https://www.codedump.info/media/imgs/20200609-btree-1/bst-example.png)

其实B树性能很不错，但是由于每个节点只能存储一个数据，可能导致树的高度会变高，每次查询的次数最坏情况会等于索引树的高度，逻辑上挨着的节点数据会离得很远（例如上面的34，35），这些问题好像不是很严重，毕竟B树是多路平衡树，可是设置合适的阶，其实这是分情况的。

在内存中操作数据，问题不大。

在磁盘中操作数据，会有一些不同点：

* 读写磁盘数据很慢。
* 读写磁盘的最小单位是数据页。

**B树是多路平衡查找树，每个节点最多包含K个子节点，K的大小取决于磁盘页的大小。**

为了**减少读写磁盘IO的次数，能够充分利用局部性原理，磁盘预读**，需要把瘦高的B树结构变成矮胖的B+树。这种数据结构特点：**每个节点能容纳更多的数据，这样就能降低树的高度，同时让逻辑上相邻的数据都能尽量的存储在物理上也相邻的硬盘空间上，减少磁盘读写。**

![img](https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png)

**当你使用主键索引时候，B+树非叶子节点存主键的值，叶子节点存整行数据。非主键索引，B+树非叶子节点存储非主键字段，叶子节点存储对应的主键值。**

在这里，一个节点越“胖”，意味着扇出（fanout）越大，同时高度越低，这两个性质决定了：

- 高扇出：邻近键值的数据局部性更好。
- 低高度：遍历期间的寻道次数更少。

### 5.聊一聊索引类型，你是怎么理解的？

#### 主键索引

主键索引又被称作聚簇索引。

对于 `InnoDB` ，`rowid` 是每个引擎用来唯一标识数据行的信息。

* 对于有主键的 `InnoDB` 来说 `rowid`就是主键 ID。
* 如果没有创建主键，系统会生成长度为 6 字节 `rowid` 来作为主键。
* 对于 `MEMORY` 引擎的 `rowid` 是数组下标。

每张表都会有主键索引。

**主键索引的叶子节点存储的是整行的数据。**

#### 二级索引(辅助索引)

唯一索引，普通索引，前缀索引等都是属于二级索引，**二级索引的叶子节点存储的数据是主键。**

* 唯一索引：唯一索引也是一种约束。**唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。** 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。
* 普通索引：**普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。**
* 前缀索引：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符，**会影响覆盖索引的使用。**

### 6.你知道哪些索引的原则？

#### 覆盖索引

🌰：

```mysql
#k是字段也是普通索引 T是表
select * from T where k between 3 and 5
```

在这个查询语句工程中，**k 索引树下查询 k=3 对应的 ID 值然后回到主键索引树中搜索所有的数据，这个过程我们称之为回表。**

```mysql
select ID from T where k between 3 and 5
```

我们需要查询的 ID 值在 k 索引树中的结果，可以直接返回查询结果，不用回表，这个过程我们称之为**覆盖索引**。在这个查询里面，对于索引树 k 已经**覆盖**了我们的查询需求。

**由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。**

#### 最左前缀原则

**B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。**

🌰：

```mysql
#现在有一个存储了id，姓名和年龄的表,姓名是索引。
select * from t where name like ‘张 %’
# 姓名，年龄是联合索引
select * from t where name like ‘张 %’
```

上面两个查询语句都可以使用索引。

**最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。**

#### 索引下推

索引下推：**可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。**

mysql 会一直向右匹配索引，直到遇到范围查询（>、<、between、like）就停止匹配。

范围列可以用到索引，但是范围列后面的列无法用到索引。即：索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。

🌰：

```mysql
#现在有一个存储了id，姓名和年龄和性别的表,# 姓名，年龄是联合索引
select * from tuser where name like '张%' and age=10 and ismale=1;
```

索引树会先查询姓张的数据，由于是 like 后面就不能用索引，通过索引下推然后再内部进行对age的判断，最后回表查询进行比较。

### 7.对一个字段，你会唯一索引还是普通索引？

* 业务要求优先：如果数据库的数据需要保证数据的唯一性，做约束，那么优先选择唯一索引。
* 如果业务没有要求，分场景去选择：
  * 写多读少的场景（账单，日志）推荐选择普通索引
  * 写多读多的场景不推荐选择普通索引。

解释（主要解释第二条）：

> 唯一索引和普通索引在查询上面性能上是差不多的。
>
> 在更新方面，两者有一定的差别：
>
> * 唯一索引：需要每次更新时候将磁盘中的数据读入内存，在进行更新操作。
> * 普通索引：当需要更新的数据在内存中就直接更新，如果不在，更新记录写入 change buffer，后面在进行 `merge`，**减少了将数据从磁盘读入内存的操作。**
>
> change buffer 发起merge的条件：
>
> * 再次访问记录的数据页
> * 定期merge
> * 数据正常关闭时候。

## 事务



## 锁

## 日志





## 

