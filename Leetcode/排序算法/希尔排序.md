# 希尔排序

1959 年一个叫 `Donald L. Shell (March 1, 1924 – November 2, 2015)` 的美国人在 `Communications of the ACM 国际计算机学会月刊` 发布了一个排序算法，从此名为希尔排序的算法诞生了。

注： `ACM = Association for Computing Machinery`，国际计算机学会，世界性的计算机从业员专业组织，创立于1947年，是世界上第一个科学性及教育性计算机学会。

希尔排序是直接插入排序的升级版本，我们知道插入排序对于一个几乎已经排好序的数列来说，效率是非常高的，达到了 `O(n)` 的时间复杂度，而希尔排序则是一种分组插入排序。

希尔排序属于插入类排序算法。

## 算法介绍

有一个 N 个整数的数列：

1. 第一次选择步长为 `N/2` ，将这些数分成一组，对这些数进行直接插入排序
2. 第二次选择步长为 `N/4`，将这些数分成一组，对这些数进行直接插入排序
3. …
4. 直到步长为 `1`，接着使用直接插入排序
5. 排序完成

这是一种分组插入排序，根据步长将元素进行分组，然后进行插入排序。

![img](https://images2018.cnblogs.com/blog/849589/201803/849589-20180331170017421-364506073.gif)

越有序的数列，插入排序的效率会越高，希尔排序通过分组使用插入排序，一开始，步长大于 `1`，可以将无序的数列变得几乎有序，比较和交换的次数也比较少，当最后步长为 `1` 的插入排序，此时的数列已经几乎有序了，时间复杂度也会低一点。

> 时间复杂度

最好的情况：数列相对有序，希尔排序会进行 `logN`  次插入排序，每次插入排序的时间复杂度为 `O(N)`，所以希尔排序时间复杂度为：`O(NlogN)`。

最坏的情况：数列反向有序，假设步长分别是：`d8 d7 d6 ... d3 d2 1`，每一轮插入排序的元素数量为：`n/d8 n/d7 n/d6 .... n/d3 n/d2 n`。

```code
假设增量序列为 ⌊N/2⌋ ，每次增量取值为比上一次的一半小的最大整数。

O( (n/d8)^2 + (n/d7)^2 + (n/d6)^2 + ... + (n/d2)^2 + n^2)

= O(1/d8^2 + 1/d7^2 + 1/d6^2 + ... + 1/d2^2 + 1) * O(n^2)
= O(等比为1/2的数列和) * O(n^2)
= O(等比求和公式) * O(n^2)
= O( (1-(1/2)^n)/(1-1/2) ) * O(n^2)
= O( (1-(1/2)^n)*2 ) * O(n^2)
= O( 2-2*(1/2)^n ) * O(n^2)
= O( < 2 ) * O(n^2)
```

希尔排序最坏时间复杂度为 `O(N^2)`。

不同的分组增量序列，有不同的时间复杂度，但是没有人能够证明哪个序列是最好的。`Hibbard` 增量序列：`1，3，7，···，2n−1` 是被证明可广泛应用的分组序列，时间复杂度为：`Θ(n^1.5)`。

希尔排序的时间复杂度大约在这个范围：`O(n^1.3)~O(n^2)`，具体还无法用数学来严格证明它。

希尔排序不是稳定的，因为每一轮分组，都使用了直接插入排序，但分组会跨越 `n` 个位置，导致两个相同的数，发现不了对方而产生了顺序变化。

## 算法实现

```go
// ShellSort 希尔排序
func ShellSort(list []int)  {
	n:=len(list)
	//设置步长
	for step:=n/2;step>=1;step/=2{
		//插入排序
		for i:=step;i<n;i+=step{
			deal:=list[i]
			j:=i-step
			for ;j>=0;j-=step{
				if deal<list[j]{
					list[j+step]=list[j]
				}else {
					break
				}
			}
			list[j+step]=deal
		}
	}
}
```

按照之前分析的几种排序算法，一般建议待排序数组为小规模情况下使用直接插入排序，在规模中等的情况下可以使用希尔排序，但在大规模还是要使用快速排序，归并排序或堆排序。