# 优先队列

堆排序( `Heap Sort` )由威尔士-加拿大计算机科学家 `J. W. J. Williams` 在 `1964` 年发明，它利用了二叉堆 `(A binary heap)` 的性质实现了排序，并证明了二叉堆数据结构的可用性。同年，美国籍计算机科学家 `R. W. Floyd` 在其树排序研究的基础上，发布了一个改进的更好的原地排序的堆排序版本。

堆排序属于选择类排序算法。

## 算法介绍

它能够完成插入一个数值，取出最小值或者最大值的任务，他不是一个之前那样的一个排序的方式，通过二叉树实现，每次取出最大值或者最小值来形成一个有序数列。

最小堆和最大堆是二叉堆的一种，是一棵完全二叉树（一种平衡树）。

最小堆的性质：

1. 父节点的值都小于左右儿子节点。
2. 这是一个递归的性质。

最大堆的性质：

1. 父节点的值都大于左右儿子节点。
2. 这是一个递归的性质。

最大堆和最小堆实现方式一样，只不过根节点一个是最大的，一个是最小的。

### 最大堆

以最大堆举例说明。

有两个操作是重要的：

1. Push：向堆中插入数据，与父亲节点进行比较，如果大于，那么就进行交换，不断向上提升，直到父节点大于此数据为止（或者根节点处）。
2. Pop：从堆中弹出最大值，然后会将最后一个值复制到根节点，删除最后一个节点，然后与子节点进行比较，如果小于，进行交换，直到整个树满足父节点大于子节点。

有的人会把这两个操作分别叫做上浮与下沉。

举例：

这是一个最大堆：

![img](https://goa.lenggirl.com/picture/heap_sort1.png)

用数组表示为：`[11 5 8 3 4]`

> 上浮

要往堆里`push` 一个元素 `15`，我们先把 `X = 15` 放到树最尾部，然后进行上浮操作。

过程如下：

`15` 与父节点 `8` 进行比较，大于父节点，进行替换：

![img](https://goa.lenggirl.com/picture/heap_sort2.png)

`15` 继续与父节点 `11` 进行比较，大于父节点，进行替换：

![img](https://goa.lenggirl.com/picture/heap_sort3.png)



最好情况：操作一次，甚至不操作，时间复杂度为 `O(1)`。

最坏的情况，到达根节点，时间复杂度为 `O(logN)`，相当于树的高度。

> 下沉

弹出根节点，也就是数组中最大值 `11`，会先将根节点移除，然后将最后的节点放到根节点上：

![img](https://goa.lenggirl.com/picture/heap_sort5.png)

然后对根节点进行调整，与子节点进行比较：

![img](https://goa.lenggirl.com/picture/heap_sort6.png)

这样不断的向下沉，达到满足最大堆的特征。

时间复杂度与上浮操作一致。

### 时间复杂度分析

我们来认认真真分析一下构建一个最大堆到拆除最大最的时间复杂度。

构建一个最大堆，从空堆开始，每次添加元素到尾部后，需要向上翻转，最坏翻转次数是：

```
第一次添加元素翻转次数：log1
第二次添加元素翻转次数：log2
第三次添加元素翻转次数：不大于log3的最大整数
第四次添加元素翻转次数：log4
第五次添加元素翻转次数：不大于log5的最大整数
...
第N次添加元素翻转次数：不大于logn的最大整数

近似 = log(1)+log(2)+log(3)+...+log(n) = log(n!)
```

从一个最大堆，逐一移除堆顶元素，然后将堆尾元素置于堆顶后，向下翻转恢复堆特征，最坏翻转次数是:

```
第一次移除元素恢复堆时间复杂度：logn
第二次移除元素恢复堆时间复杂度：不大于log(n-1)的最大整数
第三次移除元素恢复堆时间复杂度：不大于log(n-2)的最大整数
...
第N次移除元素恢复堆时间复杂度：log1

近似 = log(1)+log(2)+log(3)+...+log(n) = log(n!)
```

根据斯特林公式：

![img](https://goa.lenggirl.com/picture/heap_sort7.png)

可以进行证明 `log(n!)` 和 `nlog(n)` 是同阶的：

![img](https://goa.lenggirl.com/picture/heap_sort8.png)

所以构建一个最大堆的最坏时间复杂度是：`O(nlogn)`。

从堆顶一个个移除元素，直到移完，整个过程最坏时间复杂度也是：`O(nlogn)`。

从构建堆到移除堆，总的最坏复杂度是：`O(nlogn)+O(nlogn)`，我们可以认为是：`O(nlogn)`。

如果所有的元素都一样的情况下，建堆和移除堆的每一步都不需要翻转，最好时间复杂度为：`O(n)`，复杂度主要在于遍历元素。

如果元素不全一样，即使在建堆的时候不需要翻转，但在移除堆的过程中一定会破坏堆的特征，导致恢复堆时需要翻转。比如一个 `n` 个元素的已排好的序的数列，建堆时每次都满足堆的特征，不需要上浮翻转，但在移除堆的过程中最尾部元素需要放在根节点，这个时候导致不满足堆的特征，需要下沉翻转。因此，在最好情况下，时间复杂度仍然是：`O(nlog)`。

因此，最大堆从构建到移除，总的平均时间复杂度是：`O(nlogn)`。

## 算法实现

```go
type Heap struct {
	//堆的大小
	Size int
	// 使用内部的数组来模拟树
	// 一个节点下标为 i，那么父亲节点的下标为 (i-1)/2
	// 一个节点下标为 i，那么左儿子的下标为 2i+1，右儿子下标为 2i+2
	Array []int
}

//NewHeap
/* @Description: 初始化一个堆
 * @param array
 * @return *Heap
 */
func NewHeap(array []int) *Heap {
	return &Heap{
		Size:  0,
		Array: make([]int, len(array)),
	}
}
func (h *Heap) Push(x int) {
	//如果堆中没有元素，就将元素直接放到根节点
	if h.Size == 0 {
		h.Array[0] = x
		h.Size++
		return
	}
	//要插入节点的下标
	i := h.Size
	for i > 0 {
		//父节点下标
		parent := (i - 1) / 2
		//如果插入元素小于父亲节点，不需要动，直接退出
		if x <= h.Array[parent] {
			break
		}
		//如果插入元素大于父亲节点，进行上浮的操作，将父亲节点元素值复制到插入节点。
		h.Array[i] = h.Array[parent]
		i = parent
	}
	//插入元素
	h.Array[i] = x
	h.Size++
}
func (h *Heap) Pop() int {
	//如果堆中没有元素，就返回-1
	if h.Size == 0 {
		return -1
	}
	//取出需要弹出元素的值
	ret := h.Array[0]
	h.Size--
	//取出堆中最后一个值
	x := h.Array[h.Size]
	// 对根节点进行向下翻转，小的值 x 一直下沉，维持最大堆的特征
	i := 0
	//给最后一个元素找一个合适的位置
	for true {
		//获得子节点的下标
		a := 2*i + 1
		b := 2*i + 2
		//如果不存在左子树，那么就是叶子节点，就可以直接返回，到头了
		if a >= h.Size {
			break
		}
		// 有右子树，拿到两个子节点中较大节点的下标
		if b < h.Size && h.Array[b] > h.Array[a] {
			a = b
		}
		//找到合适的位置
		if x >= h.Array[a] {
			break
		}
		// 将较大的儿子与父亲交换，维持这个最大堆的特征
		h.Array[i] = h.Array[a]
		// 继续往下操作
		i = a
	}
	//放置元素
	h.Array[i] = x
	return ret
}


```

```go
func main() {
    list := []int{5, 9, 1, 6, 8, 14, 6, 49, 25, 4, 6, 3}

    // 构建最大堆
    h := NewHeap(list)
    for _, v := range list {
        h.Push(v)
    }

    // 将堆元素移除
    for range list {
        h.Pop()
    }

    // 打印排序后的值
    fmt.Println(list)
}
```

这样实现的堆排序是普通的堆排序，性能不是最优的。

因为一开始会认为堆是空的，每次添加元素都需要添加到尾部，然后向上翻转，需要用 `Heap.Size` 来记录堆的大小增长，这种堆构建，可以认为是非原地的构建，影响了效率。

美国籍计算机科学家 `R. W. Floyd` 改进的原地自底向上的堆排序，不会从空堆开始，而是把待排序的数列当成一个混乱的最大堆，从底层逐层开始，对元素进行下沉操作，一直恢复最大堆的特征，直到根节点。

将构建堆的时间复杂度从 `O(nlogn)` 降为 `O(n)`，总的堆排序时间复杂度从 `O(2nlogn)` 改进到 `O(n+nlogn)`。

### 算法改进

