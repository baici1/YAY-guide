# 归并排序

归并排序是一种分治策略的排序算法，与快速排序都是一个策略。通过递归的先每个子序列有序，最后将两个有序的序列进行合并成一个有序的序列。

归并排序首先由著名的现代计算机之父 `John_von_Neumann` 在 `1945` 年发明，被用在了 `EDVAC`(一台美国早期电子计算机)，足足用墨水写了 23 页的排序程序。

注：冯·诺依曼（`John von Neumann`，1903年12月28日-1957年2月8日），美籍匈牙利数学家、计算机科学家、物理学家，是 20 世纪最重要的数学家之一。

## 算法介绍

这个算法核心是如何将两个数组合并成一个有序数组。

步骤：

1. 先申请一个辅助数组，长度等于两个有序数组长度的和。
2. 利用双指针，比较两个元素，元素小的放进辅助数组，指针向后移动，重复这个操作，直至没有元素。
3. 返回辅助数组。

### 自顶而下归并排序

![img](https://goa.lenggirl.com/picture/merge_sort.png)

从上往下进行递归，直至切分数组无法进行切分，对有序数组进行合并，最后得到一个大的有序数组。

一次的两个有序数组合并成一个有序数组的时间复杂度为 `O(N)`，每次都是一分为二，这里的递归深度为`O(logN)`。那么总的时间复杂度为 `O(nlogn)`，无论是最好的情况，还是最坏的情况，都是一样的。是一个比较稳定的排序算法。

因为递归，程序栈层数会有 `logn` 层，所以递归栈的空间复杂度为：`O(logn)`。

```code
归并排序，每次归并操作比较的次数为两个有序数组的长度： n/2

T(n) = 2*T(n/2) + n/2
T(n/2) = 2*T(n/4) + n/4
T(n/4) = 2*T(n/8) + n/8
T(n/8) = 2*T(n/16) + n/16
...
T(4) = 2*T(2) + 4
T(2) = 2*T(1) + 2
T(1) = 1

进行合并也就是：

T(n) = 2*T(n/2) + n/2
     = 2^2*T(n/4)+ n/2 + n/2
     = 2^3*T(n/8) + n/2 + n/2 + n/2
     = 2^4*T(n/16) + n/2 + n/2 + n/2 + n/2
     = ...
     = 2^logn*T(1) + logn * n/2
     = 2^logn + 1/2*nlogn
     = n + 1/2*nlogn

因为当问题规模 n 趋于无穷大时 nlogn 比 n 大，所以 T(n) = O(nlogn)。

因此时间复杂度为：O(nlogn)。

```

### 自底而上归并排序

没有数组切分的步骤，就是从小数组开始排序，然后不断合并成更大的数组。

![img](https://goa.lenggirl.com/picture/merge_sort2.png)

核心都是两个数组合并成一个数组，深度都是一样的，所以时间复杂度不变，是 `O(nlogn)`。

这里不需要递归，没有程序栈使用，所以空间复杂度为 `O(N)`。

## 算法实现

自顶而下归并排序

```go
func MergeSort(list []int, begin int, end int) {
	//保证切分数组最小的长度为1
	if begin+1 < end {
		//找中间值，切分数组
		mid := begin + (end-begin+1)/2
		//分为 array[begin,mid) 和 array[mid,high)
		MergeSort(list, begin, mid)
		MergeSort(list, mid, end)
		//将数组合并成一个有序数组
		merge(list, begin, end, mid)
	}
}

func merge(array []int, begin, end, mid int) {
	leftSize := mid - begin         //左数组的长度
	rightSize := end - mid          //右数组的长度
	newSize := leftSize + rightSize //辅助数组的长度
	res := []int{}
	l, r := 0, 0 //记录左右数组元素遍历的个数
	for l < leftSize && r < rightSize {
		//左数组的值
		lValue := array[begin+l]
		//右数组的值
		rValue := array[mid+r]
		//选择元素值小的入辅助数组中
		if lValue < rValue {
			res = append(res, lValue)
			l++
		} else {
			res = append(res, rValue)
			r++
		}
	}
	//将剩下的也入组
	res = append(res, array[begin+l:mid]...)
	res = append(res, array[mid+r:end]...)
	// 将辅助数组的元素复制回原数组，这样该辅助空间就可以被释放掉
	for i := 0; i < newSize; i++ {
		array[begin+i] = res[i]
	}
}
```

自底而上归并排序

```go
func MergeSort2(array []int, begin, end int) {
	//设置步长，也是每个数组的长度
	step := 1
	//结束条件，步数大于长度
	for end-begin > step {
		//开始遍历，step<<i 是两个数组的长度
		for i := begin; i < end; i += step << 1 {
			//array[begin,mid),array[mid,end)
			var l = i               //第一个数组的左边界
			var mid = l + step      //第一个数组的右边界，第二个数组的左边界
			var r = l + (step << 1) //第二个数组的右边界
			//如果第二个数组不存在
			if mid > end {
				return
			}
			//如果第二个数组长度不够
			if r > end {
				r = end
			}
			//合并两个数组
			merge(array, l, r, mid)
		}
		//增加步长
		step <<= 1
	}
}

```

因为核心部分是一样的所以就没有重复写核心部分。

## 算法改进

思考一下哪些部分可以去进行优化？

1. 归并操作里面，我们使用了辅助数组
2. 最小的数组长度是 1。

怎么优化？

1.  原地排序
2. 小数组使用直接插入排序

第二种方式比较普通，就不多介绍了，主要介绍第一种优化！

这里介绍一种翻转算法，用于解决第一种情况。同时也有题目可以去感受一下[题目：剑指Offer58-II.左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

步骤：

1. 两个有序的数组，分别是 `arr[begin,mid-1]，arr[mid,end]`，此时初始化 `i=begin`，`j=mid`，`k=end`，从 `i~j` 为左有序的数组，`k~j`为右有序的数组，如图：

   ![img](https://goa.lenggirl.com/picture/merge_sort_y1.png)

2. 将 `i` 向后移动，找到第一个 `arr[i]>arr[j]`的索引，这个时候，`i` 前面的部分已经排好序了，`begin~i` 这些元素已经是两个有序数组的前 `n` 小个元素。如图：

   ![img](https://goa.lenggirl.com/picture/merge_sort_y2.png)

3. 然后将 `j` 向后移动，找到第一个 `arr[j]>arr[i]`的索引，如图：

   ![img](https://goa.lenggirl.com/picture/merge_sort_y3.png)

4. 这个时候，`mid~j` 中的元素都小于 `arr[i]`，前面已经知道从 `begin~i` 已经是前 `n` 小了，所以这两部分 `begin~i，mid~j` 也是有序的了，我们要想办法将这两部分连接在一起。

5. 我们只需进行翻转，将 `i~mid` 和 `mid,j-1` 部分进行位置互换即可，我们可以用手摇算法。

```go
// 手摇算法，将 array[l,l+1,l+2,...,mid-2,mid-1,mid,mid+1,mid+2,...,r-2,r-1,r] 从mid开始两边交换位置
// 1.先逆序前部分：array[mid-1,mid-2,...,l+2,l+1,l]
// 2.后逆序后部分：array[r,r-1,r-2,...,mid+2,mid+1,mid]
// 3.上两步完成后：array[mid-1,mid-2,...,l+2,l+1,l,r,r-1,r-2,...,mid+2,mid+1,mid]
// 4.整体逆序： array[mid,mid+1,mid+2,...,r-2,r-1,r,l,l+1,l+2,...,mid-2,mid-1]
func rotation(array []int, l, mid, r int) {
	reverse(array, l, mid-1)
	reverse(array, mid, r)
	reverse(array, l, r)
}

func reverse(array []int, l, r int) {
	for l < r {
		// 左右互相交换
		array[l], array[r] = array[r], array[l]
		l++
		r--
	}
}

func merge2(array []int, begin, mid, end int) {
	i, j, k := begin, mid, end-1
	for j-i > 0 && k-j >= 0 {
		step := 0
		for j > i && array[i] <= array[j] {
			i++
		}
		for k >= j && array[j] <= array[i] {
			step++
			j++
		}
		fmt.Println(i, j)
		rotation(array, i, j-step, j-1)
		i = i + step
	}
}
func MergeSortPro1(array []int, begin, end int) {
	if begin+1 < end {
		mid := begin + (end-begin)/2
		MergeSortPro1(array, begin, mid)
		MergeSortPro1(array, mid, end)
		merge2(array, begin, mid, end)
	}
}
```

最重要的部分就是那个原地排序。虽然时间复杂度可能稍稍多了一点，但存储空间复杂度降为了 `O(1)`。

归并排序是唯一一个有稳定性保证的高级排序算法，某些时候，为了寻求大规模数据下排序前后，相同元素位置不变，可以使用归并排序。