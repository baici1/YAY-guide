# 插入排序

插入排序，可以叫简单插入排序或者直接插入排序，每次把一个数插到已经排好序的数列里面形成新的排好序的数列，以此反复。

插入排序属于插入类排序算法。

## 算法介绍

🌰：`5, 9, 1, 6, 8, 14, 6, 49, 25, 4, 6, 3`

![GIF 2021-12-24 11-08-26](https://cdn.jsdelivr.net/gh/baici1/img-typora/20211224110950.gif)

> 注：
>
> 红色代表：需要排列的元素
>
> 橙色代表：已经排列好的元素
>
> 绿色代表：当前与红色进行比较的元素。

他的思想是取一个数，我在一个已经排好序得一组数列中，我找个位置给他放进去。理解起来并不难！

> 时间复杂度

对于一组数列，外层总是需要遍历 `N-1` 次，这毫无疑问。

但是内层循环取决于当前数列顺序情况：

* 最好的情况：这数列已经是排序好了得，就是从小到大得数，所以不需要移位数据，时间复杂度为：`O(1)`。
* 最坏得情况：当前数列是一个反向排序得数列（从大到小），那么每次都需要移位数据，移位次数是 `N` 次。时间复杂度为：`O(N)`。

总体来讲：最好情况时间复杂度为：`O(N)`，最坏情况时间复杂度为：`O(N^2)`。

> 空间复杂度

只用到了一个常量存储需要排序的元素，所以空间复杂度为：`O(1)`。

## 算法实现

```go
func InsertSort(list []int)  {
	//外层循环 遍历数列中每一个是数
	for i:=0;i<len(list);i++{
		//需要排列的元素
		deal:=list[i]
		//从前面一个开始
		j:=i-1
		//开始寻找合适的位置 从右向左
		for ;j>=0;j--{
			//如果当前值大于需要排列的数，那么将当前值往后移动
			if deal<list[j]{
				list[j+1]=list[j]
			}else {
				break
			}
		}
		//选择好位置的后面一个插入值
		list[j+1]=deal
	}
}
```

数组规模 `n` 较小的大多数情况下，我们可以使用插入排序，它比冒泡排序，选择排序都快，甚至比任何的排序算法都快。

数列中的有序性越高，插入排序的性能越高，因为待排序数组有序性越高，插入排序比较的次数越少。

数列中有大量无序数列下，算法的效率就会很低，和选择排序，冒泡排序一样。